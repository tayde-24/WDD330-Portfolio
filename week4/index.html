<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Week 4 Notes and Questions</title>
    <link rel="stylesheet" href="week-4.css">
  </head>
  <body>
    <div class="lesson-title">
      <h2>Week 04- Forms, OOP, and Modular JavaScript</h2>
    </div>
    <div class="content">
      <div class="chunk-1">
      <h3 class="affected-h3">Forms</h3>
      <ul class="forms-objects">
        <li>Forms are made up of a <code>form</code> element that containes form controls such as input
            fields, select menus and buttons
        </li>
        <li>Traditionally, when a form was submitted, it would be sent to a server where the information would
            processed using a "back-end" language such as <span class="emphasize">PHP or Ruby</span>
            <ul>
              <li>Now more possible to process the info. in a form on the "front-end" <i>before</i> it is sent
                sent to the server using JavaScript   
              </li>
            </ul>
        </li>
        <li>Before, they used a useful property called <code>document.forms</code> from the legacy DOM
            tht returned an HTML collection of all the forms in the document in the order they appear in
            the markup &#8594; <code>const form = document.forms[0];</code>
          <ul>
            <li>Equivalent to &#8594; <code>const form = document.getElementsByTagname("form")[0];</code></li>
          </ul>
        </li>
        <li>A form object also has a method called <code>elements</code> that returns an HTML collection
            of all the elements contained in the form.
            <ul>
              <li>In this case the form contains two controls: an input and a button element &#8594;
                <code>const [input,button] = form.elements;</code>
              </li>
              <li>Can also access te form controls using their "name" attribute as if it was a property of the 
                form object &#8594; <code>const input = form.searchInput;</code>
              </li>
            </ul>
        <li>Form Properties and Methods
          <ul>
            <li><code>form.submit()</code> method will submit the form automatically</li>
            <li>Three different ways to do it:
              <div class="h-container">
                <ul class="h-size">
                  <li>
                    <code>&#60;button type="submit"&#62;Submit&#60;button&#62;<br>
                      &#60;button type="submit" value="Submit"&#62;<br>
                      &#60;button type="image" src="button.png"&#62;  
                    </code>
                  </li>
                </ul>
              </div>
            </li>
            <li><code>form.reset()</code> &#8594; This method will reset all the form controls back to their
              initial values specified in the HTML
            </li>
            <li><code>form.action</code> &#8594; This property can be used to set the <code>action</code> attribute of a form,
              so it's sent to a different URL to be processed on the server:
              <ul>
                <li><code>form.action = "/an/other.url"</code></li>
              </ul>
            </li>
            <li>The <code>focus</code> event occurs when an element is focused on.</li>
            <li>The <code>blur</code> event occurs when the user moves the focus away from the form element</li>
            <li>The <code>change</code> event occurs when the user moves the focus away from the form element
              <i>after changing it.</i>  
            </li>
            <li><code>submit</code> &#8594; After clicking the button, the browser tries to load a nonexistent page
              <span class="emphasize">(the URL should end in something similar to <i>'.../search?searchInput=hello')</i>.</span>
              <ul>
                <li>The <code>search()</code> function was invoked after the event got fired</li>
                <li>The form was then submitted to the URL provided in the "action" attribute for processing</li>
                <li><code>preventDefault()</code> &#8594; This method stops the form from being submitted to the url
                  <div class="h-container">
                    <ul class="h-size">
                      <li><code>function search(event) {<br>alert("Form Submitted");<br>event.preventDefault();<br>}</code></li>
                    </ul>
                  </div>
                </li>
              </ul>  
            </li>
          </ul>
        </li>
        <li>Retrieving and Changing Values From a Form
          <ul>
            <li><code>value</code> &#8594; A property that can be used to retrieve the text inside the field</li>
            <li>Similar functionality to setting a value would be using the <code>placeholder</code>
              attribute in the HTML markup &#8594; The only difference is that the placeholder text is not a value
              of the input field (so the user if he fails to fill it up will be submitting a blank value)
            </li>
          </ul>
        </li>
      </li>
    </ul>
    </div>

    <div class="chunk-2">
      <h3 class="affected-h3">Form Controls</h3>
      <ul class="forms-objects">
        <li>Common Types of Form Control:
          <ul>
            <li><code>input</code> &#8594; Fields, including text, passwords, checkboxes, radio 
              buttons, and file uploads
            </li>
            <li><code>select</code> &#8594; Menus for drop-down lists of options</li>
            <li><code>textarea</code> &#8594; Elements for longer text entry</li>
            <li><code>button</code> &#8594; Elements for submitting and resetting forms</li>
            <li><code>autofocus</code> &#8594; It's an attribute to give focus to an element when a page loads</li>
          </ul>
        </li>
        <li>Text Input Fields &#8594; The default type of input is "text", which is used for entering a short piece of text</li>
        <li>Password Input Fields &#8594; <code>input type="password"</code> is used to enter passwords or secret information 
          <ul>
            <li>Kind of like type="text", but the characters are concealed as they are entered so they are unable to be read on the screen</li>
          </ul>
        </li>
        <li>Checkbox Input Fields &#8594; <code>input type="checkbox"</code> They are used to select different options that can be checked(true) or left unchecked(false)
            <ul>
              <li>User can select <i>more than one checkbox</i> from a list</li>
            </ul>
        </li>
        <li>Radio buttons &#8594; <code>input type="radio"</code> Like checkboxes, they allow users to check an option as true, but they provide an exclusive choice of 
          options, so <i>only one option</i> can be selected
        </li>
        <li>Hidden Input Fields &#8594; <code>input type="hidden"</code> These are not displayed by the browser, but have a "value" attribute
          that can contain information that is submitted with the form. <span class="emphasize">These fields are not secret and is visible in the HTML</span>  
        </li>
        <li>File Input Fields &#8594; <code>input type="file"</code> These are used to upload files, and most browsers will provide a browse button or similar
          that lets users select a file from their file system
        </li>
        <li>Other Input Types:
          <ul>
            <li><code>number</code> &#8594; Lets you enter a number</li>
            <li><code>tel</code> &#8594; Lets you enter a phone number</li>
            <li><code>color</code> &#8594; Lets you pick out a color</li>
          </ul>
        </li>
        <li>Select drop-down lists can be used to select one or more options from a list of values</li>
        <li><code>textarea</code> &#8594; An element that is used to enter long pieces of text over multiple lines such as a comment
          or blog post
        </li>
      </ul>
      
    </div>

    <div class="chunk-3">
      <h3 class="affected-h3">Form Elements</h3>
      <ul class="forms-objects">
        <li>Form validation is the process of checking whether a user has entered the information into a form correctly</li>
        <li>Validation can occur on the client side using JavaScript, and on the server side
          <ul>
            <li>Should be used to <span class="emphasize"><i>enhance</i></span> the user experience when filling in a form by
              giving feedback about any errors before it's submitted
            </li>
          </ul>
        </li>
        <li>Disabling the Submit Button
          <ul>
            <li>Another useful technique that can be aid usibility is to disable the submit button if there are errors on the form</li>
          </ul>
        </li>
      </ul>
      
    </div>


    <p class="gist">Here's a question I have: <br><br>
      There's one section of the "Hero's form that I tried out in the exercise portion, but somehow I kept getting an
        error in the console that the <code>toUpperCase()</code> was not a function. Here's what they put down in their book.
    </p>
    <ul class="forms-objects">
    <div class="h-container">
      <ul class="h-size">
        <li><code>function validateInline() {<br>const heroName = this.value.toUpperCase();<br>
          if(heroName.startsWith("X")) {<br>error.style.display = "block";<br>} else {<br>error.style.display = "none";<br>
        }<br>}</code></li>
      </ul>
    </div>
  </ul>
  <p>The <i>this</i> in the <code>heroName</code> variable, or constant, didn't seem to work at all, but when I changed it to
    <code>const heroName = form.heroName.value.toUpperCase();</code> this seemed to work. <span class="emphasize">Was I supposed to put inside some key word
    in the function, or did I miss something here?</span>
  </p>
  </div>

  <hr class="line-breaker">
  
  <div class="chunk-4">
    <h3 class="affected-h3">Object-Oriented Programming in JavaScript</h3>
    <ul class="forms-objects">
      <li>Object-Oriented Programming is a style of programming that involves separating the code into objects that have properties and methods
        <ul>
          <li>Keeps related pieces of code encapsulated in objects that maintain state throughout the life of the program</li>
          <li>Can be reused or easily be modified, as required</li>
        </ul>
      </li>
      <li>Encapsulation
        <ul>
          <li>It keeps all the programming logic inside an object and making methods available to implement the functionality,
            without the outside world needing to know <i>how it's done</i>
          </li>
        </ul>
      </li>
      <li>Polymorphism
        <ul>
          <li>This means that various objects can share the same method, but also have the ability to override the shared methods
            with a more specific implementation
          </li>
        </ul>
      </li>
      <li>Inheritence
        <ul>
          <li>It takes an object that already exists and inherit all its properties and methods &#8594; We can improve
            on its functionality by adding new properties and methods
          </li>
        </ul>
      </li>
      <li>Classes
        <ul>
          <li>Many OOP languages, such as Java and Ruby, are known as class-based languages</li>
          <li>They use class to define a blueprint of an object</li>
          <li>JavaScript didn't have classes before ES6 &#8594; Used the concepts of using actual objects as the blueprint 
            for creating more objects (become known as a prototype-based language)
          </li>
        </ul>
      </li>
      <li>Constructor Functions &#8594; This is a function that defines the properties and methods of an object
        <ul>
          <li>The keyword <code>this</code> is used to represent the object that will be returned by the constructor function</li>
          <li><span class="emphasize">The parentheses are not required when instantiating a new object using a constructor function</span></li>
          <li><span class="emphasize">The parentheses are <i>required</i>, however, if any default arguements need to be provided</span></li>
          <li>Each new object that's created using the function will inherit the properties and methods defined in the function</li>
        </ul>
      </li>
      <li>ES6 Class Declarations &#8594; This syntax does exactly the same thing as a constructor function, but looks similar to
        writing a class in a class-based programming language.
        <ul>
          <li>The names of constructor functions or class declarations are capitalized, which is the convention used for classes
            in class-based programming languages
          </li>
        </ul>
      </li>
      <li>The Constructor Property &#8594; All objects have a constructor property that returns the cunstructor function that created it
        <ul>
          <li>Can use constructor property to instantiate a copy of an object without having to reference the actual constructor function
            or class declaration directly
          </li>
        </ul>
      </li>
      <li>Static Methods &#8594; This can be used in class declarations to create a static method
        <ul>
          <li>A static method is called by the class directly rather than by instances of the class</li>
          <li>Static methods are <i>not</i> available to instances of the class</li>
        </ul>
      </li>
      <li>Prototypal Inheritence &#8594; It means that every class has a prototype property that is shared by every instance of the class</li>
      <li>Prototype &#8594; This is useful if you don't have access to the class declaration, but still want to add properties and methods to the class</li>
      <li><code>prototype</code> &#8594; This property is one of the ways we can find the prototype of an object</li>
      <li><code>Object.getPrototype()</code> &#8594; This method is another way to find the prototype of an object (this takes the object as a parameter)</li>
      <li><code>__proto__</code> &#8594; Known as dunder proto that also finds the prototype of an object (recommend using <code>
        getPrototypeOf()</code> instead</li>
      <li><code>isPrototypeOf()</code> &#8594; This method returns a boolean to check if it's the prototype of an instance</li>
      <li>The prototype can be used to add any new properties and methods after the class has been declared
        <ul>
          <li>Should be used to define any properties that will remain the same for every instance of the class</li>
        </ul>
      </li>
    </ul>
  </div>

  <div class="chunk-5">
    <h3 class="affected-h3">Public and Private Methods</h3>
    <ul class="forms-objects">
      <li>Methods and properties are said to be public because they can be queried directly and changed by assignment
        <ul>
          <li>This could become an issue giving users access these properties, so in order to avoid this, we have to keep some properties
            and methods private inside of a class declaration (prevents them from being accessed or changed)
          </li>
          <li>The use of getter and setter methods help return the property value to the user</li>
        </ul>
      </li>
    </ul>
  </div>

  <div class="chunk-5">
    <h3 class="affected-h3">Inheritence and Enumerable Properties</h3>
    <ul class="forms-objects">
      <li>Properties of objects in JavaScript are said to be enumerable or non-enumerable
        <ul>
          <li>Those that aren't enumerable will not show up when a <code>for-in</code> loop is used to loop through an 
            object's properties and methods
          </li>
          <li><code>propertyIsEnumerable() &#8594; This can be used to check if a property is enumerable</code></li>
        </ul>
      </li>
      <li>A class can inherit from another class using the <code>extends</code> keyword in a class declaration</li>
      <li>The <code>extends</code> in a way helps create a sub-class or child class of the main thing (which uses <i>super</i>
        that refers to the parent class, and can be used to access any properties and call any methods of the parent class
      </li>
      <li>Polymorphism related stuff
        <ul>
          <li>While monkey-patching built-in objects can seem a good way to add extra or missiong functionality, it can also
            add unexpected behavior
          </li>
          <li>The current consensus in the JS community is that this shouldn't be done, so avoid it unless you have a very
            good reason to do so
          </li>
        </ul>
      </li>
    </ul>
  </div>

  <div class="chunk-6">
    <h3 class="affected-h3">Property Attributes and Descriptors</h3>
    <ul class="forms-objects">
      <li>Each property has a number of attributes that provide information about the property</li>
      <li>All object properties have the following attributes stored in a property descriptor:
        <ul>
          <li><code>value</code> &#8594; This is the value of the property and is <code>underfined</code> by default</li>
          <li><code>writable</code> &#8594; This boolean value shows whether a property can be changed or not, and is false by default</li>
          <li><code>enumerable</code> &#8594; This boolean value shows whether a property will show up when the object is displayed in a 
            <code>for in</code> loop, and is "false" by default
          </li>
          <li><code>configurable</code> &#8594; This boolean value shows whether you can delete a property or change any of its attributes,
            and is <code>false</code> by default
          </li>
        </ul>
      </li>
      <li>Instead of using assignment, we can add properties to an object using the <code>Object.defineProperty()</code> method
        &#8594; This provides more fine-grained control when adding  new properties, as it allows each attribute to be set
      </li>
      <li>The <code>get()</code> and <code>set()</code> methods can be used to control how a property is set using assignment and
        the value that is returned when a property is queried
      </li>
    </ul>
  </div>

  <div class="chunk-7">
    <h3 class="affected-h3">Creating Objects from Other Objects</h3>
    <ul class="forms-objects">
      <li>The <code>Object()</code> constructor function has a method called <code>create</code> that can be used to create a new
        object that is an exact copy of the object that is provided as an arguement (acts as the prototype for the new object)
      </li>
      <li>By capitalizing the name of the object, it acts in a similar way to a class in class-based programming languages</li>
      <li>An alternative way is to add a second argument to the <code>Object.create()</code> method containing properties that are
        to be added to the new object
        <ul>
          <li>Example: <code>const jimmy = Object.create(Human, { name: { value: 'Jimmy Olsen', enumerable: true }, job: { value: 'Photographer', enumerable: true } });</code></li>
        </ul>
      </li>
      <li>Can also act like a "super-class" through inheritance</li>
    </ul>
  </div>

  <div class="chunk-8">
    <h3 class="affected-h3">Mixins and Binding <i>this</i></h3>
    <ul class="forms-objects">
      <li><span class="emphasize">What is a mixin?</span> &#8594; A mixin is a way of adding properties and methods of some objects
        to another object without using inheritance
      </li>
      <li>Basic mixin functionality is provided by the <code>Object.assign()</code> method &#8594; This will assign to the object 
        provided as the first argument all of the properties from any objects provided as further arguments
      </li>
      <li>The <code>mixin()</code> function is a particular powerful way of dealing with objects
        <ul>
          <li>You can add a large number of properties to an object all at once (See <a href="https://www.sitepoint.com/premium/books/javascript-novice-to-ninja-2nd-edition/read/12/k01nwvh1/" target="_blank_">example of this in the book</a>)</li>
          <li>You can create a <code>copy()</code> method that can be used to make an exact, deep copy of an object</li>
        </ul>
      </li>
      <li><code>this</code> allows us to create generalized methods that refer to properties specific to a particular object</li>
      <li>To solve the "this" that's referencing the property of the global window object, here are some solutions:
        <ul>
          <li>Set the variable <code>that</code> to equal <code>this</code> before the nested function, and refer to <code>that</code> the 
            nested function instead of <code>this</code></li>
          <li><code>bind()</code> &#8594; A method for all functions and is used to set the value of <code>this</code> in the function</li>
          <li><code>for-of</code> &#8594; This syntax is for arrays and this does not require a nested function to be used</li>
          <li>Use of arrow functions &#8594; They don't have their own <code>this</code> context</li>
        </ul>
      </li>
    </ul>
  </div>

  <div class="chunk-9">
    <h3 class="affected-h3">Composition Over Inheritence</h3>
    <ul class="forms-objects">
      <li>There are a number of benefits to OOP, but there are also some problems that come with inheritence</li>
      <li>Though you inherit the class to gain access to that method that inherits other properties and methods that you don't need,
        it becomes unnecessarily bloated
      </li>
      <li>A design pattern that seeks to solve these problems is to use "composition over inheritence"</li>
      <li>If you do classes, don't have them contain to many properties and methods</li>
      <li>If you want to use a particular method from a class but has lots of properties and methods you don't need, then it would be
        preferable to just "borrow" the method instead
      </li>
    </ul>
  </div>

  <hr class="line-breaker">

  <div class="chunk-10">
    <h3 class="affected-h3">Modular Javascript</h3>
    <ul class="forms-objects">
      <li><span class="emphasize">What is a module?</span> &#8594; It is a self-contained piece of code that provides functions and
        methods that can then be used in other files and by other modules
        <ul>
          <li>Helps keep code organized in separate, reusable files, which improves code maintainability</li>
          <li>Keeping code modular helps to make it more loosely coupled and interchangeable, meaning you can easily swap one module
            for another without affecting other parts of a project
          </li>
          <li>Small single-purpose modules are the exact opposite of large monolithic libraries as they enable developers to use
            the modules that are needed, avoiding any wasted code
          </li>
          <li>They also allow a public API to be exposed, while keeping the implementation hidden away inside the module</li>
        </ul>
      </li>
      <li>For a long time, JavaScript didn't support modules, but native support for them was finally added in ES6
        <ul>
          <li>All code in modules is always in strict mode without the need for "use strict" and there is no way to opt out of this</li>
          <li>A module has its own global scope, so any variables created in the top-level of a module can only be accessed within that module</li>
          <li>The value of <code>this</code> in the top level of a module is <code>undefined</code>, rather than the global object</li>
          <li>You can't use HTML-style comments in modules</li>
        </ul>
      </li>
      <li>You can be selective in which values or functions to import from the module</li>
      <li>If there are lots of values and functions that need to be imported, then everything in a module file can be imported using the
        wildcard symbol <code>*</code> along with a namespace for the imported values and functions 
        <ul>
          <li>Example: <code>import * as stats from "./stats.js";</code></li>
        </ul>
      </li>
      <li><span class="emphasize">Default Exports</span> &#8594; This refers to a single variable, function or class in a module that can
        be improved without having to be explicitly named
      </li>
      <li>The big difference with default exports is that you don't need to use curley braces or make any mention of the value that is being
        imported, making the statement read more elegantly
      </li>
    </ul>
  </div>

  <div class="chunk-11">
    <h3 class="affected-h3">Node.js Modular</h3>
    <ul class="forms-objects">
      <li>Node.js had already implemented modules before they were introduced in ES6, and used a slightly different notation
        called Common JS modules
      </li>
      <li>A Common JS module is created in a separate file, and the <code>module.exports</code> method is used to make any functions
        available  to other files, in a similar way to ES6 modules
      </li>
    </ul>
  </div>

    <div class="next-page">
      <p>Here's the <a href="exercise/exercise.html"> form and team exercises.</a></p>
    </div> 

      
    <div class="go-back">
      <a href="portfolio/../.."> &#8592; Go back to Portfolio page</a>
    </div>
    
    <footer>
      <div class="bottom-footer">
        <p>Copyright 2022 Brigham Young University-Idaho</p>
      </div>
    </footer>
  </body>
</html>
